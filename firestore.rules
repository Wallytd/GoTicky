rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    function isSignedIn() {
      return request.auth != null;
    }

    function isOwner(userId) {
      return request.auth != null && request.auth.uid == userId;
    }

    // Only allow favorites to be a reasonable list length (client-side typed in app code).
    function validFavorites(data) {
      return !('favorites' in data) ||
        (data.favorites is list &&
          data.favorites.size() <= 500);
    }

    // Allow only known roles.
    function roleAllowed(data) {
      return !('role' in data) || data.role in ["customer", "admin"];
    }

    function validAdminSecure(data) {
      return ('email' in data && data.email is string && data.email.size() > 0) &&
             ('password' in data && data.password is string && data.password.size() > 0) &&
             (!('rememberMe' in data) || data.rememberMe is bool);
    }

    function validBanner(data) {
      return ('title' in data && data.title is string && data.title.size() > 0) &&
             (!('order' in data) || data.order is int) &&
             (!('active' in data) || data.active is bool);
    }

    // Public profile index validation for pre-auth avatar lookup on sign-in.
    function validPublicProfile(data, emailLower) {
      return ('emailLower' in data && data.emailLower == emailLower) &&
        (!('displayName' in data) || (data.displayName is string && data.displayName.size() <= 120)) &&
        (!('email' in data) || (data.email is string && data.email.size() > 0)) &&
        (!('photoUri' in data) ||
          // Allow null or omitted photoUri (user may not have uploaded an avatar yet),
          // but bound non-null string length.
          data.photoUri == null ||
          (data.photoUri is string && data.photoUri.size() <= 2000));
    }

    function immutableUid(userId, data) {
      return !('uid' in data) || data.uid == userId;
    }

    // Canonical per-user document keyed by Firebase UID or seeded key.
    // Write is allowed for the owner OR for signed-in seeders writing role=admin (for initial admin import).
    match /users/{userId} {
      allow read: if isOwner(userId);
      allow write: if (
          (isOwner(userId)) ||
          (isSignedIn() && request.resource.data.role == "admin")
        ) &&
        immutableUid(userId, request.resource.data) &&
        validFavorites(request.resource.data) &&
        roleAllowed(request.resource.data);

      // Per-user app settings subcollection, e.g. /users/{uid}/app_settings/preferences
      match /app_settings/{docId} {
        allow read, write: if
          isOwner(userId) ||
          (isSignedIn() &&
            (('email' in request.auth.token && request.auth.token.email == userId) ||
             ('emailLower' in request.auth.token && request.auth.token.emailLower == userId)));
      }
    }

    // Global app settings. Keep admin_secure readable for backwards compatibility only.
    match /app_settings/{docId} {
      // Allow reads for bootstrapping legacy secure admin sign-in configs even before auth/app-check succeeds.
      allow read: if docId == "admin_secure";
      // Writes to the legacy admin_secure document are no longer allowed; new configs live under adminProfiles.
      allow write: if false;
    }

    // Admin profiles collection used for admin control room and per-admin settings.
    match /adminProfiles/{adminName} {
      allow read: if true;
      // Admin profile documents are seeded server-side or via the app's seeding utilities while signed in.
      allow write: if isSignedIn();

      // Per-admin app settings, e.g. /adminProfiles/{adminName}/app_settings/admin_secure
      match /app_settings/{docId} {
        // Allow reads for secure admin bootstrap regardless of auth state so the app can fetch
        // pre-configured secure credentials and then perform its own gating.
        allow read: if docId == "admin_secure";

        // Writes must pass the same validation as the legacy admin_secure document.
        // We intentionally do not require auth here so the client can bootstrap secure
        // admin config even if Firebase Auth is not fully wired yet.
        allow write: if
          docId == "admin_secure" &&
          validAdminSecure(request.resource.data);
      }
    }

    // Hero/marketing banners shown on the public home screen.
    // Allow anyone to read banners, writes limited to signed-in sessions (including
    // anonymous) so only the app/admin tools can modify them.
    match /banners/{bannerId} {
      allow read: if true;
      allow write: if validBanner(request.resource.data);
    }

    // Human-friendly user directory index for console/admin inspection.
    // Structure: /userDirectory/{role}/{nameKey}/{uid}
    match /userDirectory/{role}/{nameKey}/{uid} {
      allow write: if isSignedIn();
      allow read: if false;
    }

    // Public, minimal profile index keyed by lowercased email for pre-auth avatar lookup.
    match /publicProfiles/{emailLower} {
      allow read: if true;
      allow write: if isSignedIn() &&
        validPublicProfile(request.resource.data, emailLower);
    }

    // Deny everything else.
    match /{document=**} {
      allow read, write: if false;
    }
  }
}
