rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    function isSignedIn() {
      return request.auth != null;
    }

    function isOwner(userId) {
      return request.auth != null && request.auth.uid == userId;
    }

    // Only allow favorites to be a reasonable list length (client-side typed in app code).
    function validFavorites(data) {
      return !('favorites' in data) ||
        (data.favorites is list &&
          data.favorites.size() <= 500);
    }

    function roleAllowed(data) {
      return !('role' in data) || data.role in ["customer", "admin"];
    }
    function isAdminUser() {
      return isSignedIn() &&
        exists(/databases/$(database)/documents/users/$(request.auth.uid)) &&
        get(/databases/$(database)/documents/users/$(request.auth.uid)).data.role == "admin";
    }

    function validAdminSecure(data) {
      return ('email' in data && data.email is string && data.email.size() > 0) &&
             ('password' in data && data.password is string && data.password.size() > 0) &&
             (!('rememberMe' in data) || data.rememberMe is bool);
    }

    function validBanner(data) {
      return ('title' in data && data.title is string && data.title.size() > 0) &&
             (!('order' in data) || data.order is int) &&
             (!('active' in data) || data.active is bool);
    }

    function validNewsFlash(data) {
      return ('title' in data && data.title is string && data.title.size() > 0) &&
        ('summary' in data && data.summary is string) &&
        ('source' in data && data.source is string) &&
        ('tag' in data && data.tag is string) &&
        (!('category' in data) || data.category is string) &&
        (!('accentHex' in data) || data.accentHex is string || data.accentHex == null) &&
        (!('imageUrl' in data) || data.imageUrl is string || data.imageUrl == null) &&
        (!('imageKey' in data) || data.imageKey is string || data.imageKey == null) &&
        (!('ctaLabel' in data) || data.ctaLabel is string || data.ctaLabel == null) &&
        (!('ctaLink' in data) || data.ctaLink is string || data.ctaLink == null) &&
        (!('publishedAt' in data) || data.publishedAt is string) &&
        (!('expiresAt' in data) || data.expiresAt is string || data.expiresAt == null) &&
        (!('priority' in data) || data.priority is int) &&
        (!('pinned' in data) || data.pinned is bool) &&
        (!('status' in data) || data.status in ["draft", "scheduled", "published", "archived"]) &&
        (!('region' in data) || data.region is string || data.region == null) &&
        (!('locale' in data) || data.locale is string || data.locale == null) &&
        (!('author' in data) || data.author is string || data.author == null) &&
        (!('createdBy' in data) || data.createdBy is string || data.createdBy == null) &&
        (!('updatedAt' in data) || data.updatedAt is string || data.updatedAt == null) &&
        (!('impressions' in data) || data.impressions is int) &&
        (!('clicks' in data) || data.clicks is int);
    }

    function validTonightsHeat(data) {
      return ('title' in data && data.title is string && data.title.size() > 0) &&
        ('metaLine' in data && data.metaLine is string) &&
        ('captionLine1' in data && data.captionLine1 is string) &&
        (!('captionLine2' in data) || data.captionLine2 is string || data.captionLine2 == null) &&
        (!('imageUrl' in data) || data.imageUrl is string || data.imageUrl == null) &&
        (!('imageKey' in data) || data.imageKey is string || data.imageKey == null) &&
        (!('accentHex' in data) || data.accentHex is string || data.accentHex == null) &&
        (!('primaryCtaLabel' in data) || data.primaryCtaLabel is string || data.primaryCtaLabel == null) &&
        (!('secondaryCtaLabel' in data) || data.secondaryCtaLabel is string || data.secondaryCtaLabel == null) &&
        (!('eventId' in data) || data.eventId is string || data.eventId == null) &&
        (!('active' in data) || data.active is bool) &&
        (!('order' in data) || data.order is int);
    }

    function validRecommendation(data) {
      return ('eventId' in data && data.eventId is string && data.eventId.size() > 0) &&
        ('title' in data && data.title is string && data.title.size() > 0) &&
        ('reason' in data && data.reason is string) &&
        ('tag' in data && data.tag is string) &&
        ('city' in data && data.city is string) &&
        ('priceFrom' in data && data.priceFrom is string) &&
        (!('imageKey' in data) || data.imageKey is string || data.imageKey == null) &&
        (!('imageUrl' in data) || data.imageUrl is string || data.imageUrl == null) &&
        (!('order' in data) || data.order is int) &&
        (!('active' in data) || data.active is bool);
    }

    function validNewsFlashExpiryWindow(data) {
      return
        // No expiry set is always allowed.
        !('expiresAt' in data) ||
        data.expiresAt == null ||
        // If we don't know publishedAt, skip the check.
        !('publishedAt' in data) ||
        // When both are strings, require expiresAt >= publishedAt.
        ((data.publishedAt is string) && (data.expiresAt is string) && data.expiresAt >= data.publishedAt);
    }

    // Public profile index validation for pre-auth avatar lookup on sign-in.
    function validPublicProfile(data, emailLower) {
      return ('emailLower' in data && data.emailLower == emailLower) &&
        (!('displayName' in data) || (data.displayName is string && data.displayName.size() <= 120)) &&
        (!('email' in data) || (data.email is string && data.email.size() > 0)) &&
        (!('photoUri' in data) ||
          // Allow null or omitted photoUri (user may not have uploaded an avatar yet),
          // but bound non-null string length.
          data.photoUri == null ||
          (data.photoUri is string && data.photoUri.size() <= 2000));
    }

    function immutableUid(userId, data) {
      return !('uid' in data) || data.uid == userId;
    }

    // Canonical per-user document keyed by Firebase UID or seeded key.
    // Write is allowed for the owner OR for signed-in seeders writing role=admin (for initial admin import).
    match /users/{userId} {
      allow read: if isOwner(userId);
      allow write: if (
          (isOwner(userId)) ||
          (isSignedIn() && request.resource.data.role == "admin")
        ) &&
        immutableUid(userId, request.resource.data) &&
        validFavorites(request.resource.data) &&
        roleAllowed(request.resource.data);

      // Per-user app settings subcollection, e.g. /users/{uid}/app_settings/preferences
      match /app_settings/{docId} {
        allow read, write: if
          isOwner(userId) ||
          (isSignedIn() &&
            (('email' in request.auth.token && request.auth.token.email == userId) ||
             ('emailLower' in request.auth.token && request.auth.token.emailLower == userId)));
      }
    }

    // Global app settings. Keep admin_secure readable for backwards compatibility only.
    match /app_settings/{docId} {
      // Allow reads for bootstrapping legacy secure admin sign-in configs even before auth/app-check succeeds.
      allow read: if docId == "admin_secure";
      // Writes to the legacy admin_secure document are no longer allowed; new configs live under adminProfiles.
      allow write: if false;
    }

    // Admin profiles collection used for admin control room and per-admin settings.
    match /adminProfiles/{adminName} {
      allow read: if true;
      // Admin profile documents are seeded server-side or via the app's seeding utilities while signed in.
      allow write: if isSignedIn();

      // Per-admin app settings, e.g. /adminProfiles/{adminName}/app_settings/admin_secure
      match /app_settings/{docId} {
        // Allow reads for secure admin bootstrap regardless of auth state so the app can fetch
        // pre-configured secure credentials and then perform its own gating.
        allow read: if docId == "admin_secure";

        // Writes must pass the same validation as the legacy admin_secure document.
        // We intentionally do not require auth here so the client can bootstrap secure
        // admin config even if Firebase Auth is not fully wired yet.
        allow write: if
          docId == "admin_secure" &&
          validAdminSecure(request.resource.data);
      }
    }

    // Hero/marketing banners shown on the public home screen.
    // Allow anyone to read banners, writes limited to signed-in sessions (including
    // anonymous) so only the app/admin tools can modify them.
    match /banners/{bannerId} {
      allow read: if true;
      allow write: if isSignedIn() && validBanner(request.resource.data);
    }

    match /newsFeeds/{flashId} {
      allow read: if true;
      allow write: if
        validNewsFlash(request.resource.data) &&
        validNewsFlashExpiryWindow(request.resource.data);
    }

    match /tonightsHeat/{heatId} {
      allow read: if true;
      allow write: if isSignedIn() && validTonightsHeat(request.resource.data);
    }

    match /recommendations/{recId} {
      allow read: if true;
      allow write: if isSignedIn() && validRecommendation(request.resource.data);
    }

    // Human-friendly user directory index for console/admin inspection.
    // Structure: /userDirectory/{role}/{nameKey}/{uid}
    match /userDirectory/{role}/{nameKey}/{uid} {
      allow write: if isSignedIn();
      allow read: if false;
    }

    // Public, minimal profile index keyed by lowercased email for pre-auth avatar lookup.
    match /publicProfiles/{emailLower} {
      allow read: if true;
      allow write: if isSignedIn() &&
        validPublicProfile(request.resource.data, emailLower);
    }

    // Deny everything else.
    match /{document=**} {
      allow read, write: if false;
    }
  }
}
